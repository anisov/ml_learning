import numpy
# модель которая соответствует нейроной сети слои которой соеденины друг с другом
from keras.models import Sequential
# Тип слоёв нейронной сети, который мы будем использовать называется dense в этом типе слоёв выполняется
# соединение всех нейронов предыдущего уровня, со всеми нейронами следующего уровня
from keras.layers import Dense
# утилиты для работы с масивами
from keras.utils import np_utils
from keras.datasets import mnist

"""
Так как мы используем стохастические методы оптимизации, то для повторяемости 
результатов желательно задать сид генератора случайных чисел.
"""

numpy.random.seed(42)

"""
В библиотеке керос реализованы методы для загрузки популярных наборов данных для
алгоритмов машинного обучения, мы можем не загружать набор данных мнист вручную и разбирать его,
а воспользоваться существующими методами mnist.load_data(). Он возвращает два набора данных 
для обучения и для тестов.
X_train набор данных с картинками, y_train правильный ответ для каждой картинки.
"""

(X_train, y_train), (X_test, y_test) = mnist.load_data()

"""
Перед тем как обучать сеть, нужно необходимо выполнить предварительную обработку
входных данных - менять размерность входного массива
"""

X_train = X_train.reshape(60000, 784)
X_test = X_test.reshape(10000, 784)

"""
Для того, что бы получить лучшее качество обучения мы нормализуем данные, 
интенсивность каждого пикселя будет от 0 до 1.
"""

X_train = X_train.astype('float32')
X_test = X_test.astype('float32')
X_train /= 255
X_test /= 255

"""
Преобразовать правильные ответы для представления по категориям.
"""

Y_train = np_utils.to_categorical(y_train, 10)
Y_test = np_utils.to_categorical(y_test, 10)

"""
Подготовили входные данные и можем создавать нашу нейронную сеть.
Для описания нейронной сети керос использует модель. Тут используем sequential().
Последовательная модель в которой слои нейронной сети идут друг за другом.
В модель добавляем два наших слоя на 1) входном слое 800 нейронов, у каждого из этих нейронов
784 входа по количеству пикселей на входном изображение, веса входных изображений инициализируются случайно
с помощью нормального распределения.
"""

model = Sequential()
model.add(Dense(800, input_dim=784, init='normal', activation='relu'))

"""
Второй слой состоит из 10 нейронов, входные веса инициализируются случайными значениями с помощью 
нормального распределения. Функция активации softmax.
"""

model.add(Dense(800, input_dim=784, activation="relu", kernel_initializer="normal"))
model.add(Dense(10, activation="softmax", kernel_initializer="normal"))

"""
Оба слоя сети имеют тип Dense при этом типе слоя выполняется соединение всех нейронов одного уровня
со всеми нейронами следующего уровня. 
"""

"""
После описания модели необходимо её скомпилировать. При компиляции мы задаем параметры, которые будут использоваться
при обучение. Метод обучения SGD метод стохастического градиентного спуска, в качестве меры ошибки
мы будем использовать не среднеквадратичное отклонение, а categorical_crossentropy, эта мера ошибки лучше 
подходит для нашегослучая, когда в качестве выходного значения у нас есть несколько категорий, каждая из категорий 
соответствует рукописной цифре и метрика, по который мы будем выполнять оптимизацию - это точность. 
После того как модель скомпилирована можно написать краткие её характеристики. 
"""

model.compile(loss='categorical_crossentropy', optimizer='SGD', metrics=['accuracy'])

print(model.summary())

"""
Для обучения сети используется метод fit, этому методу необходимо указать данные на которых мы будем обучать сеть,
правильные ответы, размеры мини выборки составляет 200 элементов, мы анализируем 200 изображений, определяем
направление градиента и в соответствие с этим направлением выполняем изменение весов, после этого анализируем 
следующие 200 изображений и ещё раз изменяем веса, следующее - это количество эпох, сколько раз выполняем 
обучение с помощью нашего набора данных, в нашем случае 100, мы обучаем есть с помощью одного и того же набора 
изображение(60 тысяч) и параметр verbose позволяет печатать диагностическую информацию в процессе обучения.
"""

model.fit(X_train, Y_train, batch_size=200, epochs=100, validation_split=0.2, verbose=2)

"""
Обучение сети завершено, теперь мы можем использовать эту сеть, что бы распознавать рукописные цифры, в качестве теста
попробуем, что бы модель выдала предсказание для того же набора данных, на которым мы её обучали. Для этого используется
метод модели predict, которому мы должны указать набор данных.
"""

predictions = model.predict(X_train)

"""
Значение предсказанные сетью необходимо преобразовать из представления в виде категорий, которая содержит 
вероятность принадлежности цифры к тому или иному классу в метку, то есть число от 0 до 9.
"""

predictions = np_utils.to_categorical(predictions)
print(predictions)

"""
После того как мы выполнили преобразование, мы можем сравнить ответы которые выдала сеть
с правильными ответами, которые содержатся в переменной y_train
"""

scores = model.evaluate(X_test, Y_test, verbose=0)
print("Точность работы на тестовых данных: %.2f%%" % (scores[1]*100))