import numpy
from keras.models import Sequential
from keras.layers import Dense
from keras.datasets import boston_housing

numpy.random.seed(42)
(X_train, y_train), (X_test, y_test) = boston_housing.load_data()
print(X_train)

"""
Стандартизация данных.
Привести все признаки к одной шкале.
Стандартизация означает преобразование данных таким образом, 
что бы их новое среднее значение являлось нулём, а дисперсия 1.
Алгоритм:
1) Из каждого признака нужно вычесть его среднее значение.
2) Разделить на стандартное отклонение.

Рассчитываем среднее значение и стандартное отклонение с помощью numpy, axis=0, 
это означает что мы рассчитываем среднее значение не по всему тензору, а
отдельное среднее значение и стандартное отклонение для каждого признака.
Затем вычитаем среднее значение отдельно для каждого признака и делим на стандартное отклонение.
"""

mean = X_train.mean(axis=0)
std = X_train.std(axis=0)
X_train -= mean
X_train /= std
X_test -= mean
X_test /= std

model = Sequential()
model.add(Dense(128, activation='relu', input_shape=(X_train.shape[1],)))

"""
Наша сеть должна выдавать одно действительное значение, средняя стоимость жилья в нужном районе, поэтому 
входной нейрон один. На выходном слое мы не используем нелинейную функцию активации, применяется обычный 
линейный нейрон. Для задачи регрессии нам не нужно приводить значение к какому-то диапазону, например от 0 до 1, 
наоборот, нам нужно обычное действительное число, поэтому нелинейная функции активации не применяется.
"""

model.add(Dense(1))

"""
В качестве функции ошибки, которая будет использоваться в оптимизаторе алгоритма обратного 
распространения ошибки, мы выбираем среднеквадратичную ошибку mse-ср.квад. ошибка, mae - 
средняя абсолютная ошибка.
В качестве метрики, при решение задачи классификации, мы использовали accuracy, т.е. процент 
правильных ответов в сети.
При решение задач регрессии, мы уже не можем использовать accuracy т.к. на выходе у нас непрерывные 
действительные числа.
И нам важно знать на сколько сильно число, которое выдало нам нейронная сеть, отличается от правильного ответа, 
для этого в примере мы используем среднюю абсолютную ошибку. 
Так же в качестве метрике accuracy можно использовать и средне квадратичную ошибку, но ср.
абсолютную ошибку проще интерпретировать.
"""

model.compile(optimizer='adam', loss='mse', metrics=['mae'])
model.fit(X_train, y_train, epochs=100, batch_size=1, verbose=2)
mse, mae = model.evaluate(X_test, y_test, verbose=0)

"""
С помощью метода model.predict выполним расчёт цены сразу для всех данных из тестового набора.
"""

predict = model.predict(X_test)
print(predict[1][0], y_test[1])
print(predict[50][0], y_test[50])
print(predict[100][0], y_test[100])


